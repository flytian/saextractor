options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
//  STATIC = true;
  STATIC = false;
//  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
//  USER_CHAR_STREAM = true;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  OPTIMIZE_TOKEN_MANAGER = true;
}
PARSER_BEGIN(GrmTokenizer)

package ex.reader.tokenizer;

/** A grammar-based tokenizer based on JavaCC.
 * <p> This is inspired by the tokenizer implementation in Lucene.
 */

import java.io.*;
import ex.features.TokenTypeF;

public class GrmTokenizer {

  public static void main(String args[]) throws ParseException {
    GrmTokenizer parser = new GrmTokenizer(System.in);
  }

  public void copyConstants() {
    TokenTypeF.getSingleton().setTokenTypes(tokenImage);
  }
}

PARSER_END(GrmTokenizer)

TOKEN : { // token patterns

  // number sequence with more than 1 dots [,.] in the middle or at the end
  // <NUMDOTS: (<DIGIT>)+ (("."|",") (<DIGIT>)+){2,100} (<DIGIT>)*>
  // [,.] was not good for sizes like 14.5,16.5
  <NUMDOTS: (<DIGIT>)+ ((".") (<DIGIT>)+){2,100} (<DIGIT>)*>

  // floating point number with [,.] as the separator and optionally one [,] in the int part
| <FLOAT: ((<DIGIT>)+ (",") (<DIGIT>)+ ((".") (<DIGIT>)+)?) | ((<DIGIT>)+ (".") (<DIGIT>)+) >

  // integer number
| <INT: (<DIGIT>)+ >

  // dimensions
//| <DIM2: <INT> ("x" | "\u00d7" | "/") <INT> >

//| <DIM3: <INT> ( ("x" | "\u00d7" | "/") <INT> ) {2} >

//| <DIMN: <INT> ( ("x" | "\u00d7" | "/") <INT> ) {3,5} >

// alpha+num; both required
// | <ALPHANUM: ( (<LETTER>|<DIGIT>)+ | <ALPHAANDNUM> ) >
// | <ALPHANUM: ( (<LETTER>)+ (<ALPHAANDNUM>|<DIGIT>) ) >

| <ALPHA: (<LETTER>)+>

| <ALPHANUM: ( (<LETTER>)+ (<DIGIT>)+ (<LETTER>|<DIGIT>)* ) >

| <NUMALPHA: ( (<DIGIT>)+ (<LETTER>)+ (<LETTER>|<DIGIT>)* ) >

// alpha+num; both at least once
//| <#ALPHAANDNUM: ( (((<LETTER>|<DIGIT>)* <HAS_DIGIT> <HAS_LETTER> (<LETTER>|<DIGIT>)*) | 
//                    ((<LETTER>|<DIGIT>)* <HAS_LETTER> <HAS_DIGIT> (<LETTER>|<DIGIT>)*)) ) >

// internal apostrophes: O'Reilly, you're, O'Reilly's
| <APOS: <ALPHA> ("'" <ALPHA>)+ >

  // acronyms: U.S.A., I.B.M., etc.
| <ACRONYM: <ALPHA> "." (<ALPHA> ".")+ >

  // company names like AT&T
| <COMPANY: <ALPHA> ("&") <ALPHA> >

  // email addresses
| <EMAIL: (<ALPHANUM>|<NUMALPHA>|<ALPHA>|<INT>) (("."|"-"|"_") (<ALPHANUM>|<NUMALPHA>|<ALPHA>|<INT>))* "@" (<ALPHANUM>|<NUMALPHA>|<ALPHA>|<INT>) (("."|"-") (<ALPHANUM>|<NUMALPHA>|<ALPHA>|<INT>))+ >

  // hostname
| <HOST: ("http://")? (<ALPHANUM>|<ALPHA>) (("."|"-") (<ALPHANUM>|<ALPHA>))* "." 
   ("com"|"org"|"edu"|"eu"|"gov"|"mil"|"cz"|"es"|"gr"|"de"|"pl"|"ru"|"au"|
    "it"|"uk"|"fr"|"fi"|"ch"|"hu"|"sk"|"nl"|"bg"|"cn"|"ro"|"cu"|"ar"|"br")>

  // hostname with url
| <URL: <HOST> ("/" (<ALPHANUM>|<ALPHA>|<NUMALPHA>|<FLOAT>|<INT>|"."|"-"|"_")+)+ >

// floating point, serial, model numbers, ip addresses: every other segment must have at least one digit
//  | <NUMWORD: (<ALPHANUM>  <P> <HAS_DIGIT>
//          | <HAS_DIGIT>  <P> <ALPHANUM>
//          | <ALPHANUM>  (<P> <HAS_DIGIT>  <P> <ALPHANUM>)+
//          | <HAS_DIGIT> (<P> <ALPHANUM>   <P> <HAS_DIGIT>)+
//          | <ALPHANUM>   <P> <HAS_DIGIT> (<P> <ALPHANUM> <P> <HAS_DIGIT>)+
//          | <HAS_DIGIT>  <P> <ALPHANUM>  (<P> <HAS_DIGIT> <P> <ALPHANUM>)+
//        )
//  >

| <P: ("_"|"-"|"/"|"\\"|"."|","|":"|";"|"&"|"\""|"'"|"@"|"("|")"|"["|"]"|"+"|"%"|"°"|"½") >

| <SIGN: ("$"|"£"|"€"|"\u00d7") >

// phone number
// | <PHONE: ((<DIGIT>){8,12} | (("(")? ("+")? (<DIGIT>){0,3} (")")? ("-")?)? ((<DIGIT>){2,4} ("-")?){2,4} (<DIGIT>){2,4}) >

//| <#HAS_DIGIT:					  // at least one digit
//    (<LETTER>|<DIGIT>)*
//    <DIGIT>
//    (<LETTER>|<DIGIT>)*
//  >
//| <#HAS_LETTER:					  // at least one letter
//    (<LETTER>|<DIGIT>)*
//    <LETTER>
//    (<LETTER>|<DIGIT>)*
// >

| < #LETTER:					  // unicode letters
      [
       "\u0041"-"\u005a",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u0376"-"\u0377",
       "\u0386",
       "\u0388"-"\u038a",
       "\u038c",
       "\u038e",
       "\u0390"-"\u03a1",
       "\u03a3"-"\u03ff"
      ]
  >
| < CJK:                                          // non-alphabets
      [
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
| < #DIGIT:					  // unicode digits
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

// skip unrecognized chars
SKIP : {
 <NOISE: ~[] >
}

/** Returns the next TokenAnnot in the stream, or null at EOS.
 * <p>The returned tokenAnnot.type is set to {@link GrmTokenizerConstants#tokenImage}.
 */
ex.reader.TokenAnnot next() throws IOException :
{
  Token token = null;
}
{
  ( token = <NUMDOTS> |
    token = <FLOAT> |
    token = <INT> |
//    token = <ALPHAANDNUM> |
//    token = <DIM2> |
//    token = <DIM3> |
//    token = <DIMN> |
    token = <ALPHANUM> |
    token = <NUMALPHA> |
    token = <APOS> |
    token = <ACRONYM> |
    token = <COMPANY> |
    token = <EMAIL> |
    token = <HOST> |
    token = <URL> |
//    token = <PHONE> |
//    token = <NUMWORD> |
    token = <ALPHA> |
    token = <CJK> |
    token = <P> |
    token = <SIGN> |
    token = <EOF>
   )
    {
      if (token.kind == EOF) {
	return null;
      } else {
	return 
	  new ex.reader.TokenAnnot(token.kind, token.beginColumn-1, token.endColumn, null, -1, -1, token.image);
      }
    }
}
